* Grocery Store Spree
  :PROPERTIES:
  :header-args: :noweb yes :exports both :eval no-export
  :END:
** Problem
   Consider the following map of a grocery store:

   #+Name: grocery-store-chart
   #+begin_src ditaa :file grocery-store-chart.png
     +----------------------------------------------------------------------------------------------------------------------+
     |                  Meat                                                                                                |
     |Milk                                                                                                                  |
     |          +-+               +-+                             +-+                                                Seafood|
     |          |*|               |*|                             |*|             +--------------+                          |
     |          |*|               |*|                             |*|             |              |                          |
     |          |*|               |*|                             |*|             |Potatoes      |                          |
     |          |*|               |*|                         Salt|*|             |              |                          |
     |Cheese    |*|ToiletPaper    |*|                             |*|             +--------------+                          |
     |          |*|               |*|                             |*|Cilantro                                               |
     |          |*|               |*|                             |*|                                                       |
     |Eggs      |*|               |*|Mustard         +-+          |*|                                                       |
     |          |*|               |*|                |*|          |*|                                                       |
     |          |*|               |*|                |*|          |*|           +-----------+           +-----------+       |
     |          |*|               |*|       Sunscreen|*|          |*|           |           |           |           |       |
     |          |*|               |*|                |*|          |*|           |Onions     |           |Garlic     |       |
     |          |*|               |*|                |*|          |*|           |           |           |           |       |
     |          |*|               |*|                |*|          |*|           |           |           |           |       |
     |          |*|               |*|                |*|          |*|           +-----------+           +-----------+       |
     |          +-+               +-+                +-+          +-+                                                       |
     |                                                                                                                      |
     |                                                                                                                      |
     |                                                                                                                      |
     | +-------------------------+                                                                                          |
     | |                         |                                                                                          |
     | |Alcohol                  |                                                                                          |
     | |                         |                                                                                          |
     +----------------------------------------------------------------------------------------------------------------------+
   #+end_src

   The top left-most corner is at position =row=0, column=0=

*** Challenge 1
    :PROPERTIES:
    :CUSTOM_ID: challenge-1
    :END:
    Parse the map above to determine the location of each word as a =(row,column)= tuple

*** Challenge 2
    :PROPERTIES:
    :CUSTOM_ID: challenge-2
    :END:
    The position of an item is determined by
    - The location of its first capital letter
    - Unless it bumps up against a wall on the right (eg Seafood, Salt) in which case it is the location is that of its last letter

*** Challenge 3
    :PROPERTIES:
    :CUSTOM_ID: challenge-3
    :END:
    Which items are line of sight to each other? Shelves (asterisk-filled) block line of sight but bins do not.


** Challenge 1 - Location of Words
   - [[#challenge-1][Challenge statement]]

   The idea here is pretty simple actually since all text is horizontal, just read in all instances of words in each line while keeping track of rows. Simplest way to find a word in a line - regex.
   #+begin_src python :noweb no-export :exports both
     from re import finditer
     from typing import List

     def get_products_and_positions(chart: List[str]):
         for r,line in enumerate(chart):
             try:
                 for m in finditer('[A-Z]\w+', line):
                     yield (m.group(), r, m.start(0))
             except ValueError:
                 pass

     chart = (l.strip() for l in """
      <<grocery-store-chart>>
     """.strip().split('\n'))

     return list(get_products_and_positions(chart))
   #+end_src

   #+RESULTS:
   | Meat        |  1 |  19 |
   | Milk        |  2 |   1 |
   | Seafood     |  3 | 112 |
   | Potatoes    |  6 |  78 |
   | Salt        |  7 |  57 |
   | Cheese      |  8 |   1 |
   | ToiletPaper |  8 |  14 |
   | Cilantro    |  9 |  64 |
   | Eggs        | 11 |   1 |
   | Mustard     | 11 |  32 |
   | Sunscreen   | 14 |  39 |
   | Onions      | 15 |  76 |
   | Garlic      | 15 | 100 |
   | Alcohol     | 25 |   3 |


** Challenge 2 - Location of Items
   - [[#challenge-2][Challenge Statement]]

   Similar idea but we want to know whether the word ends in a wall (=|= character) or not.

   #+begin_src python :noweb no-export :exports both
     from re import finditer
     from typing import List

     def get_products_and_positions(chart: List[str]):
         for r,line in enumerate(chart):
             try:
                 for m in finditer('[A-Z]\w+\|?', line):
                     c = m.start(0) if not m.group().endswith('|') else (m.end(0) - 1)
                     yield (m.group().strip('|'), r, c)
             except ValueError:
                 pass

     chart = (l.strip() for l in """
      <<grocery-store-chart>>
     """.strip().split('\n'))

     return list(get_products_and_positions(chart))
   #+end_src

   #+RESULTS:
   | Meat        |  1 |  19 |
   | Milk        |  2 |   1 |
   | Seafood     |  3 | 119 |
   | Potatoes    |  6 |  78 |
   | Salt        |  7 |  61 |
   | Cheese      |  8 |   1 |
   | ToiletPaper |  8 |  14 |
   | Cilantro    |  9 |  64 |
   | Eggs        | 11 |   1 |
   | Mustard     | 11 |  32 |
   | Sunscreen   | 14 |  48 |
   | Onions      | 15 |  76 |
   | Garlic      | 15 | 100 |
   | Alcohol     | 25 |   3 |

** Challenge 3 - Line of Sight
   :PROPERTIES:
   :header-args: :exports code :eval no
   :END:
   - [[#challenge-3][Challenge Statement]]

*** What is Line of Sight?
    So firstly I guess we need to consider what line of sight actually is when the space is two dimensional and discrete. For example lets say we're going from cell =F= to cell =T=, what cells are in our line of sight?

    #+begin_src ditaa
      +-----+-----+-----+-----+-----+-----+-----+
      |     |     |     |     |     |     |     |
      +-----+-----+-----+-----+-----+-----+-----+
      |  F  |     |     |     |     |     |     |
      +-----+-----+-----+-----+-----+-----+-----+
      |     |     |     |     |     |     |     |
      +-----+-----+-----+-----+-----+-----+-----+
      |     |     |     |     |     |     |  T  |
      +-----+-----+-----+-----+-----+-----+-----+
    #+end_src

    What I think I would like to do is to draw a natural (non-discrete) line from the mid-point of =F= to the mid-point of =T=. We can consider every square that line passes through to be a part of its line of sight (since anything occupying that cell is considered to block path through any part of that cell.

    #+begin_src ditaa
      +-----+-----+-----+-----+-----+-----+-----+
      |     |     |     |     |     |     |     |
      +-----+-----+-----+-----+-----+-----+-----+
      |■■F■■|■■■■■|     |     |     |     |     |
      +-----+-----+-----+-----+-----+-----+-----+
      |     |■■■■■|■■■■■|■■■■■|■■■■■|     |     |
      +-----+-----+-----+-----+-----+-----+-----+
      |     |     |     |     |■■■■■|■■■■■|■■T■■|
      +-----+-----+-----+-----+-----+-----+-----+
    #+end_src


*** Calculate point of intersection
    Ok, so we're going to need a way of walking along a path and announcing which cells we enter. To do that, we need to be able to tell were a line from an arbitrary point in a square to a point outside of it will intersect the square.
    #+begin_src ditaa
      0,0
      +-----------------------+
      |                       |
      |                       |
      |    F                  |
      |                       |
      |w                      |
      |                       |
      |                       |
      |           w           |i
      +-----------------------+

      .                                    T
    #+end_src

    So on the line from =F= to =T=, what is the location at the intersection point =i=

    So for the time being let's assume that we know that the intersection point will be on the right-most wall.

    If we draw a right angle triangle from F to T it should pass through that point

    [[./trigonometry-of-path-through-square.png]]


    So we know that \(x_i = w\). This means that what we want to solve for is \(y_i\) so we have

    \begin{equation}
    a_{outer}=y_T - y_F                                 \\
    b_{outer}=x_T - x_F                                 \\
    b_{inner}=w-x_F                                     \\
    θ=\arctan{\frac{a_{outer}}{b_{outer}}}              \\
    \tan(θ) = \frac{a_{inner}}{b_{inner}}               \\
    a_{inner} = b_{inner} \tan{θ}                       \\
    a_{inner} = (w-x_F) {\tan{θ}}                       \\
    a_{inner} = (w-x_F) {\frac {a_{outer}} {b_{outer}}} \\
    a_{inner} = (w-x_F) {\frac {y_T - y_F} {x_T - x_F}} \\
    y_i = y_F + a_{inner}                               \\
    y_i = y_F + (w-x_F) \frac {y_T - y_F} {x_T - x_F}   \\
    \end{equation}

    Let's do a sanity check here.

    | *Square Width*                 | 10                                                |
    | *F(rom)*                       | (2,7)                                             |
    | *T(o)*                         | (15, 11)                                          |
    | *(i)ntersection approximation* | about (10, 9)                                     |
    | *(i)ntersection calculated*    | \((10, 7 + (10-2) \frac {11-7} {15-2}) = 9.4615\) |

    That looks right!


*** Find wall intersected

    Consider the triangle from the previous section again. Without having someone eyeball it, how can we know /which/ side is being crossed?

    We know the ratio between the sides of inner triangle and outer triangle must be true

    \begin{equation}
      \frac{a_{outer}}{b_{outer}} = tan{θ}                      \\
      \frac{a_{inner}}{b_{inner}} = tan{θ}                      \\
      \frac{a_{inner}}{b_{inner}} = \frac{a_{outer}}{b_{outer}} \\
    \end{equation}

    If crossing the *right* side, \(b_{inner}\) is known but \(a_{inner}\) is not.

    \begin{equation}
      a_{inner} = b_{inner}\frac{a_{outer}}{b_{outer}}
    \end{equation}

    If crossing the *bottom* side, \(b_{inner}\) is not known but \(a_{inner}\) is.

    \begin{equation}
      b_{inner} = a_{inner}\frac{b_{outer}}{a_{outer}}
    \end{equation}

    We do both calculations, if the slope from =F= to the intersection point described by that triangle is not the same as the one between =F= and =T= then we know it cannot be on that side

    Lets double check this with some real numbers


    #+NAME:square-side-crossed-examples
    | Side/Edge | \(x_F\) | \(y_F\) | \(x_T\) | \(y_T\) | \(a_{outer}\) | \(b_{outer}\) |
    | =w=10=    |         |         |         |         |               |               |
    |-----------+---------+---------+---------+---------+---------------+---------------|
    | Bottom    |       8 |       7 |      12 |      15 |             8 |             4 |
    | Right     |       9 |       4 |      13 |      12 |             8 |             4 |
    | Right     |       4 |       1 |      12 |       3 |             2 |             8 |
    | BR Corner |       9 |       8 |      11 |      12 |             4 |             2 |
    
    | Left      |       1 |       8 |      -1 |      11 |             3 |            -2 |
    #+TBLFM: $6=$5-$3::$7=$4-$2

    #+begin_src python :var examples=square-side-crossed-examples :eval yes
      width = 10
      def is_valid_intersection(point):
          return next((False for loc in point if loc<0 or loc>width), True)
      def get_side_and_intersection():
          for (side_or_edge, xF,yF,xT,yT,*_) in examples[2:]:
              a_outer = yT-yF
              b_outer = xT-xF

              a_to_bottom = width-yF
              b_inner_if_a_to_bottom = a_to_bottom * (1.0*b_outer/a_outer)
              bottom_intersection = (xF+b_inner_if_a_to_bottom, yF+a_to_bottom)

              b_to_right = width-xF
              a_inner_if_b_to_right = b_to_right * (1.0*a_outer/b_outer)
              right_intersection = (xF+b_to_right, yF+a_inner_if_b_to_right)
              if bottom_intersection == right_intersection:
                  yield ("BR Corner", bottom_intersection)
              elif is_valid_intersection(bottom_intersection):
                  yield ("Bottom", bottom_intersection)
              elif is_valid_intersection(right_intersection):
                  yield ("Right", right_intersection)
              else:
                  raise Exception(f"{a_to_bottom} {b_to_right}")

      return list(get_side_and_intersection())
    #+end_src

    #+RESULTS:
    | Bottom    | (9.5 10)  |
    | Right     | (10 6.0)  |
    | Right     | (10 2.5)  |
    | BR Corner | (10.0 10) |
